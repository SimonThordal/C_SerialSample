/*
 * improcess.h
 *
 *  Created on: Mar 13, 2012
 *      Author: Nihuepana
 */


#ifndef IMPROCESS_H_
#define IMPROCESS_H_

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#pragma pack(2)


typedef struct
{
    char signature[2];
    unsigned int fileSize;
    unsigned int reserved;
    unsigned int offset;
} BmpHeader;

typedef struct
{
    unsigned int headerSize;
    unsigned int width;
    unsigned int height;
    unsigned short planeCount;
    unsigned short bitDepth;
    unsigned int compression;
    unsigned int compressedImageSize;
    unsigned int horizontalResolution;
    unsigned int verticalResolution;
    unsigned int numColors;
    unsigned int importantColors;

} BmpImageInfo;

typedef struct
{
    unsigned char blue;
    unsigned char green;
    unsigned char red;
    //unsigned char reserved; Removed for convenience in fread; info.bitDepth/8 doesn't seem to work for some reason
} Rgb;

// Vertex struct
struct Vertex {
	float coords[3];
};

// Voxel structure containing vertices
struct Voxel
{
	struct Vertex vertices[8];
};

// Linked list node of faces for use in voxelization of the binary data

struct Face
{
	struct Vertex faceVertex[3];
	float normal[3];
	struct Face *next;
};

/************************************************************************************************
 * These are structures for use with the marching cubes implementation, not in voxelization
 * Marching cubes states that traversing a grid of numerical using a cube like structure you can
 * recreate the surface described by all grid values above or below a certain threshold by checking
 * if the grid at each cube vertex is above or below the threshold value.
 * The vertices of the grid are defined as shown below
 * 							4----------5
 * 						   /|         /|
 *	 					  7----------6 |
 *	 					  | |        | |
 *	 					  | 0--------|-1
 *	 					  |/         |/
 *	 					  3----------2
 * Each cube edge also carries an index from 0 to 11 which will allow us for recreating the actual
 * isosurfaces using a set of triangle vertices generated by checking which of 256 different combinations
 * of cube vertices that are above or below the threshold.
 * The algorithm is implemented as shown by Paul Bourke at http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/
 ************************************************************************************************/
struct MClookupTables
{
// List of all 256 different combinations of voxel edges being cut
const int edgeTable[256] = {0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
		0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
		0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
		0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
		0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
		0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
		0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
		0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
		0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
		0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
		0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
		0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
		0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
		0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
		0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
		0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
		0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
		0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
		0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
		0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
		0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
		0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
		0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
		0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
		0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
		0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
		0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
		0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
		0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
		0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
		0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
		0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0};
// Indices of triangle vertices sorted after which combination of cut edges they represent.
// -1 corresponds to a nonincluded index
const int triTable[256][16] =
	{{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
	{3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
	{3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
	{3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
	{9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
	{9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
	{2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
	{8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
	{4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
	{3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
	{1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
	{4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
	{4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
	{5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
	{2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
	{9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
	{0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
	{2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
	{10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
	{5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
	{5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
	{9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
	{0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
	{1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
	{10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
	{8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
	{2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
	{7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
	{2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
	{11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
	{5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
	{11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
	{11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
	{1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
	{9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
	{5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
	{2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
	{6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
	{3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
	{6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
	{10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
	{6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
	{8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
	{7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
	{3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
	{0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
	{9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
	{8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
	{5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
	{0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
	{6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
	{10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
	{10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
	{8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
	{1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
	{0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
	{10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
	{3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
	{6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
	{9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
	{8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
	{3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
	{6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
	{0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
	{10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
	{10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
	{2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
	{7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
	{7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
	{2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
	{1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
	{11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
	{8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
	{0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
	{7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
	{10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
	{2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
	{6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
	{7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
	{2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
	{1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
	{10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
	{10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
	{0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
	{7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
	{6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
	{8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
	{9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
	{6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
	{4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
	{10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
	{8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
	{0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
	{1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
	{8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
	{10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
	{4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
	{10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
	{5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
	{11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
	{9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
	{6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
	{7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
	{3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
	{7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
	{3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
	{6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
	{9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
	{1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
	{4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
	{7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
	{6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
	{3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
	{0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
	{6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
	{0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
	{11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
	{6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
	{5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
	{9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
	{1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
	{1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
	{10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
	{0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
	{5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
	{10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
	{11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
	{9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
	{7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
	{2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
	{8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
	{9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
	{9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
	{1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
	{9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
	{5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
	{0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
	{10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
	{2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
	{0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
	{0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
	{9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
	{5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
	{3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
	{5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
	{8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
	{0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
	{9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
	{1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
	{3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
	{4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
	{9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
	{11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
	{11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
	{2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
	{9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
	{3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
	{1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
	{4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
	{3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
	{0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
	{9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
	{1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};
};

/*
 * Struct representing a point in space along with its x,y,z coordinates
 */

struct XYZ
{
	float x,y,z;
};

/*
 * Allocate a x*y*3 array of the type char
 */
int ***alloc3D(int xlen, int ylen, int zlen) {
	int i, j, ***array;
	if ((array = malloc(xlen*sizeof(int**)))==NULL) {
		perror("Error in first assignment of 3D malloc\n");
	}
	// Allocate pointers for each row
	for (i = 0; i < xlen; i++) {
		if ((array[i] = malloc(ylen*sizeof(int*)))==NULL){
			perror("Error in second assignment of 3D malloc\n");
		}
		// Allocate pointer for each column in the row
		for (j=0; j < ylen; j++) {
			if((array[i][j] = malloc(zlen*sizeof(int)))==NULL) {
				perror("Error in third assignment of 3D malloc\n");
			}
		}
	}

	return array;
}

/*
 * Allocates a 2D float array
 */
float **alloc2Dfloat(int xlen, int ylen) {
	float **array;
	int i;
	array = malloc(xlen*sizeof(float*));
	// Allocate pointers for each row
	for (i = 0; i < xlen; i++) {
		array[i] = malloc(ylen*sizeof(float));
	}

	return array;
}

/*
 * Allocates a 2D int array
 */
int **alloc2Dint(int xlen, int ylen) {;
	int i, **array;
	array = malloc(xlen*sizeof(int*));
	// Allocate pointers for each row
	for (i = 0; i < xlen; i++) {
		array[i] = malloc(ylen*sizeof(int));
	}

	return array;
}
/*
 * Deallocate a l*m*n char array. Has the disadvantage that the caller needs to know the
 * dimensions of the passed array
 */
void dealloc3D(int*** arr3D,int l,int m)
{
    int i,j;

    for(i=0;i<l;i++)
    {
        for(j=0;j<m;j++)
        {
                free(arr3D[i][j]);
        }
        free(arr3D[i]);
    }
    free(arr3D);
}

/*
 * Deallocate a l*m array.
 */

void dealloc2Dfloat(float** arr2D, int l)
{
    int i;

    for(i=0;i<l;i++)
    {
        free(arr2D[i]);
    }
    free(arr2D);
}

void dealloc2Dint(int** arr2D, int l)
{
    int i;

    for(i=0;i<l;i++)
    {
        free(arr2D[i]);
    }
    free(arr2D);
}

/* loadBMP:
 * loads a 24bit RGB .bmp file and returns its header. The entire reading part is structured around
 * fread not returning to origin when reading the stream.
 */

BmpHeader readBmpHeader(FILE *inFile) {
	rewind(inFile);
	BmpHeader header;
	if( fread(&header, 1, sizeof(BmpHeader), inFile) != sizeof(BmpHeader) ) {
				printf( "Error reading bmp header.\n" );
	}
	return header;
}

/*
 * Reads and returns the DIB header of a bmp file
 */

BmpImageInfo readBmpInfo(FILE *inFile) {
	// Make sure the file is at the right position
	fseek(inFile, 14, SEEK_SET);
	BmpImageInfo info;
	if( fread(&info, 1, sizeof(BmpImageInfo), inFile) != sizeof(BmpImageInfo)) {
		printf("Error reading info header.\n");
	}
	return info;
}

/*
 * Reads the palette or colormap of a bmp image
 */
Rgb *readPalette(FILE *inFile, BmpImageInfo info) {
	// Set the file position indicator at just past the info
	fseek(inFile, 14+sizeof(info), SEEK_SET);
	Rgb *palette;
	printf( "Reading palette.\n" );
	palette = (Rgb*)malloc(sizeof(Rgb) * info.numColors);
	if( fread(palette, sizeof(Rgb), info.numColors, inFile) != (info.numColors * sizeof(Rgb)) ) {
		printf( "Error reading palette.\n" );
	}
	return palette;
}

/*
 * Reads the actual bitmap values of a bmp image.
 */

int ***readBitmap(FILE *inFile, BmpImageInfo info, int*** array) {
	Rgb *pixel = malloc( sizeof(Rgb) );
	int read, j, i;
	for( j=0; j<info.height; j++ ) {
		read = 0;
		for( i=0; i<info.width; i++ ) {
			if( fread(pixel, 1, sizeof(*pixel), inFile) != sizeof(*pixel) ) {
					printf( "Error reading pixel!\n" );
			}
			array[j][i][0] = (int)(pixel->red);
			array[j][i][1] = (int)(pixel->green);
			array[j][i][2] = (int)(pixel->blue);
			read += sizeof(*pixel);
		}

		if ( read % 4 != 0 ) {
			read = 4 - (read%4);
			printf( "Padding: %d bytes\n", read );
			fread( pixel, read, 1, inFile );
		}
	}
	free(pixel);

	return array;
}

/*
 * Pads an inputimage with a border of zeroes
 */

int **padImage(BmpImageInfo info, int** image, int** outImage) {
	int i,j;
	for (i = 0; i < info.height +1; i++) {
		for (j = 0; j < info. width +1; j++) {
			if (i==0 || i == info.height +2 || j == 0 || j == info.width + 2)
				outImage[i][j] = 0;
			else
				outImage[i][j] = image[i-1][j-1];
		}
	}
	return outImage;
}

/*
 * Finds a threshold for
 */

int otsuThresh(int** gray, BmpImageInfo info) {
	int histogram[256];
	int i,j,total, threshold = 0, bgW = 0, fgW = 0, sum = 0;
	float bgMean, fgMean, bgSum = 0, varBetween, varmax = 0;

	total = info.height*info.width;
	for(i = 0; i < 256; i++) {
		histogram[i] = 0;
	}
	for (i = 0; i < info.height; i++) {
		for (j = 0; j < info.width; j++) {
		histogram[(gray[i][j])]++;
		}
	}

	for (i = 0; i < 256; i++)
		sum += i*histogram[i];

	for (i = 0; i < 256; i++) {
		bgW += histogram[i];
		if (bgW == 0) {
			continue;
		}
		if (bgW == total)
			break;

		fgW = total - bgW;

		bgSum += (float)(i*histogram[i]);

		bgMean = bgSum / bgW;

		fgMean = (sum - bgSum) / fgW;

		varBetween = (float)bgW * (float)fgW * (bgMean - fgMean) * (bgMean - fgMean);

		if (varBetween > varmax) {
			varmax = varBetween;
			threshold = i;
		}
	}

	return threshold;
}
/*
 * Converts an rgb image to a grayscale image. The function doesn't weight the individual channels as
 * there is no need for the image to be visually appealing.
 */
int **toGrayscale(BmpImageInfo info, int*** rgbImage, int** gray) {
	int i,j;
	for (i = 0; i < info.height; i++ ) {
		for (j= 0; j < info.width; j++) {
			gray[i][j] = ((rgbImage[i][j][0]+rgbImage[i][j][1]+rgbImage[i][j][2])/3);
		}
	}
	return gray;
}

/*
 * Converts a grayscale image to binary, where all values above a provided threshold are set to 255 and
 * all values below the threshold are set to 0.
 */
int **toBinaryImage(BmpImageInfo info, int** gray, int** binaryImage, int threshold) {
	int i, j;
	for (i = 0; i < info.height; i++ ) {
			for (j= 0; j < info.width; j++) {
				if (gray[i][j]>= threshold)
					binaryImage[i][j] = 0;
				else
					binaryImage[i][j] = 1;
			}
		}
	return binaryImage;
}

/*
 * Contains an implementation of the Moore neighbor algorithm for finding the contours of a binary
 * image. Boundaries are marked with 1 and everything else with 0.
 */
int **findBoundaries(BmpImageInfo info, int** binaryImage, int** boundaryImage) {
	int i, j, k;
	int **paddedImage;
	char inside = 0;

	// Define constants used for traversing the neightborhood starting from the pixel to the lower left of the starting pixel
	int neighborhood[8][2] = {{-1,-1},{0,-1},{1,-1},{1,0},{-1,0},{-1,1},{0,1},{1,1}};
	// Create a canvas for the boundary image of the size of the binaryImsage
	for (i = 0; i < info.height+1; i++) {
		for (j = 0; j < info.width+1; j++) {
			boundaryImage[i][j] = 0;
		}
	}

	// Pad the input image with a 0 boundary
	paddedImage = alloc2Dint(info.height+1, info.width+1);
	paddedImage = padImage(info, binaryImage, paddedImage);

	//Traverse the padded image
	for (i = 1; i < info.height; i++) {
		for (j = 1; j < info.width; j++) {
			// If a solid is found and inside is false an already discovered area is entered
			if (boundaryImage[i][j] == 1 && inside == 0) {
				inside = 1;
				// printf("Entered an already found boundary\n");
			}

			// No solid found and we're not inside
			else if (paddedImage [i][j] == 0 && inside == 0) {
				continue;
			}

			// No solid found and the previous step was inside means that the algorithm is leaving a border
			else if (paddedImage [i][j] == 0 && inside == 1) {
				inside = 0;
			}

			// If we are encountering a new border pixel
			else if (paddedImage [i][j] == 1 && inside == 0) {
				// printf("finding boundary\n");
				inside = 1;
				boundaryImage[i][j] = 1;

				// Traverse the boundary
				for (k = 0; k < 8; k++) {
					if (paddedImage[i+neighborhood[k][0]][j+neighborhood[k][1]] == 1 && boundaryImage[i+neighborhood[k][0]][j+neighborhood[k][1]] == 0) {
						boundaryImage[i+neighborhood[k][0]][j+neighborhood[k][1]] = 1;
						// printf("Set boundary at %i,%i\n",i+neighborhood[k][0],j+neighborhood[k][1]);
					}
				}

			}
		}
	}
	dealloc2Dint(paddedImage,info.height+1);

	return boundaryImage;
}
/*
 * Finds the normal of a triangle based on its vector span. The vectors are determined using the vertices of the triangle.
 */
void *findNormal(float *normalVector, struct Vertex a, struct Vertex b, struct Vertex c) {
	//printf("Entered findnormals.\n");

	// Define the vectors of the coordinates of the vertices
	float aVector[3] = {a.coords[0], a.coords[1], a.coords[2]};
	float bVector[3] = {b.coords[0], b.coords[1], b.coords[2]};
	float cVector[3] = {c.coords[0], c.coords[1], c.coords[2]};

	// Vectors spanning the triangle
	float vzx[3] = {aVector[0]-cVector[0], aVector[1]-cVector[1], aVector[2]-cVector[2]};
	float vzy[3] = {bVector[0]-cVector[0], bVector[1]-cVector[1], bVector[2]-cVector[2]};

	// The normalvector is the crossproduct of the vzx and vzy
	normalVector[0] = vzx[1]*vzy[2] - vzx[2]*vzy[1];
	normalVector[1] = vzx[2]*vzy[0] - vzx[0]*vzy[2];
	normalVector[2] = vzx[0]*vzy[1] - vzx[0]*vzy[1];
	//printf("Normals: %f %f %f\n", normalVector[0], normalVector[1], normalVector[2]);

}

/*
 * push a face item to the front of a linked list.
 */
void push(struct Face **headRef, struct Vertex vertex1, struct Vertex vertex2, struct Vertex vertex3) {
	struct Face *newFace = malloc(sizeof(struct Face));
	float *normalPointer;
	normalPointer = newFace -> normal;
	newFace -> faceVertex[0] = vertex1;
	newFace -> faceVertex[1] = vertex2;
	newFace -> faceVertex[2] = vertex3;
	findNormal(normalPointer, vertex1, vertex2, vertex3);
	newFace -> next = *headRef;
	*headRef = newFace;
}
/**
 * Find the coordinates of the vertices of the voxel passed as current. Coordinates are based on the system having origin in [0,0,0]
 *
 */
void findVertices(struct Voxel *current, int i, int j, int k, float scale[3]) {
	//printf("Entered findVertices.\n");
	int x,y,z, count;
	count = 0;
	// Find the center coordinates of the current voxel
	float voxelCenter[3] = {(float)i*scale[0]+scale[0]/2., (float)j*scale[1]+scale[1]/2., (float)k*scale[2]+scale[2]/2.};

	// Set the coordinates of current based on the coordinates of the center of the voxel. Currently this is finding negative coordinates, so the center should probably be incremented by one half.
	for(z = 1;z<3;z++) {
		for (y = 1; y < 3; y++) {
			for (x = 1; x < 3; x++) {
				current -> vertices[count].coords[0] = voxelCenter[0]+pow(-1,(float)x*scale[0])/2;
				current -> vertices[count].coords[1] = voxelCenter[1]+pow(-1,(float)y*scale[1])/2;
				current -> vertices[count].coords[2] = voxelCenter[2]+pow(-1,(float)z*scale[2])/2;
				count++;
			}
		}
	}
}

/*
 * Check if a pixel has any neighbors. If not it can be assumed that the pixel is noise and not part of the structure.
 * Returns 0 if a neighbor is found, -1 if the pixel is solitary.
 */
int solitaryCheck(int*** array, int ci, int cj, int ck) {
	int i,j,k;

	for(i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			for(k = 0; k < 3; k++) {
				if (array[ci-1+i][cj-1+j][ck-1+k] == 1)
					return 0;
			}
		}
	}

	return -1;
}
/*
 * Voxelization algorithm that takes a binary boundary image and converts it to a set of voxels, which are returned in the form of a linked list.
 * Checks all elements of an array if they are equal to a threshold value specified as one and if so computes coordinates of the vertices that the voxel consists of.
 * Each rectangular voxel face consists of two triangular faces so for each boundary found two triangles are added to the linked list.
 * TODO: Input a threshold value instead of defaulting the threshold to 1 to be able to experiment with using non-binary values.
 * TODO: Add inside / outside surface recognition akin to what is found in marching cubes.
 * TODO: Add reconstruction resolution support.
 * TODO: Use the same structs as the ones used in marching cubes.
 * TODO: Take a linked list instead of an input array, as boundary detection has already been run and there is no need to reexamine pixels that are known to not be on the boundary.
 */
struct Face *findVertexFaces(BmpImageInfo *info, int depth, int*** inputArray, float* scale) {
	//printf("Entered findVertexFaces.\n");
	struct Face *head = NULL;
	int i,j,k;
	struct Voxel currentVoxel, *currVoxPoint;
	currVoxPoint = &currentVoxel;
	// TODO Check these indices, they are out of bounds
	for(i = 1; i < info->height-1; i++) {
		for (j = 1; j < info->width-1; j++) {
			for(k = 1; k < depth-1; k++) {
				// If the array location is a boundary determine coordinates of the voxel
				if (inputArray[i][j][k] == 1) {
					findVertices(currVoxPoint, i,j,k, scale);
						// Check to see if each face is a boundary face, if so create the two faces corresponding to the boundary of the voxel
						if (i!= 0 && inputArray[i-1][j][k] != 1) {
							push(&head, currVoxPoint->vertices[0], currVoxPoint->vertices[4], currVoxPoint->vertices[6]);
							push(&head, currVoxPoint->vertices[6], currVoxPoint->vertices[2], currVoxPoint->vertices[0]);
						}
						if (i!= info->height-1 && inputArray[i+1][j][k] != 1) {
							push(&head, currVoxPoint->vertices[1], currVoxPoint->vertices[3], currVoxPoint->vertices[7]);

							push(&head, currVoxPoint->vertices[7], currVoxPoint->vertices[5], currVoxPoint->vertices[1]);

						}
						if (j!= 0 && inputArray[i][j-1][k] != 1) {
							push(&head, currVoxPoint->vertices[0], currVoxPoint->vertices[1], currVoxPoint->vertices[5]);
							push(&head, currVoxPoint->vertices[5], currVoxPoint->vertices[4], currVoxPoint->vertices[0]);

						}
						if (j!= info->width-1 && inputArray[i][j+1][k] != 1) {
							push(&head, currVoxPoint->vertices[2], currVoxPoint->vertices[6], currVoxPoint->vertices[7]);
							push(&head, currVoxPoint->vertices[7], currVoxPoint->vertices[3], currVoxPoint->vertices[2]);
						}
						if (k != 0 && inputArray[i][j][k-1] != 1) {
							push(&head, currVoxPoint->vertices[0], currVoxPoint->vertices[2], currVoxPoint->vertices[3]);
							push(&head, currVoxPoint->vertices[3], currVoxPoint->vertices[1], currVoxPoint->vertices[0]);
						}
						if (k != 0 && inputArray[i][j][k+1] != 1) {
							push(&head, currVoxPoint->vertices[4], currVoxPoint->vertices[5], currVoxPoint->vertices[7]);
							push(&head, currVoxPoint->vertices[7], currVoxPoint->vertices[6], currVoxPoint->vertices[4]);
						}

					}
				}

			}

		}
	return head;

	}

/*
 * Create the grid cell that needs to be passed to marching cubes
 */
int createGrid(struct Grid *current, int ***array, int i, int j, int k) {

	int x,y,z, count;

	float voxelCenter[3] = {(float)i*scale[0]+scale[0]/2., (float)j*scale[1]+scale[1]/2., (float)k*scale[2]+scale[2]/2.};

		// Set the coordinates of current based on the coordinates of the center of the voxel. Currently this is finding negative coordinates, so the center should probably be incremented by one half.
		for(z = 1;z<3;z++) {
			for (y = 1; y < 3; y++) {
				for (x = 1; x < 3; x++) {
					current -> vertices[count].coords[0] = voxelCenter[0]+pow(-1,(float)x*scale[0])/2;
					current -> vertices[count].coords[1] = voxelCenter[1]+pow(-1,(float)y*scale[1])/2;
					current -> vertices[count].coords[2] = voxelCenter[2]+pow(-1,(float)z*scale[2])/2;
					count++;
				}
			}
		}
}

/*
 * Interpolates the coordinates of the triangle vertices bases on the coordinates of the cube vertices.
 * This function is not ready to be used for non binary images, however I'd like to use Paul Bourkes version that actually interpolates once necessary.
 * Based on the work of Paul Bourke, http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/, 1994.
 */

struct XYZ VertexInterpolate(struct XYZ p1, struct XYZ p2) {
	// return variabel
	struct XYZ p;

	// Very difficult interpolation procedure
	p.x = p1.x + (p2.x - p1.x)/2;
	p.y = p1.y + (p2.y - p1.y)/2;
	p.z = p1.z + (p2.z - p1.z)/2;

	return p;
}

int MCpolygonize(struct Voxel *voxel, struct Face *head, int threshold, struct MClookupTables *tables) {
	int cubeindex = 0;
	XYZ vertlist[struct 12];
	if (voxel->vertices[0] < threshold) cubeindex |= 1;
	if (voxel->vertices[1] < threshold) cubeindex |= 2;
	if (voxel->vertices[2] < threshold) cubeindex |= 4;
	if (voxel->vertices[3] < threshold) cubeindex |= 8;
	if (voxel->vertices[4] < threshold) cubeindex |= 16;
	if (voxel->vertices[5] < threshold) cubeindex |= 32;
	if (voxel->vertices[6] < threshold) cubeindex |= 64;
	if (voxel->vertices[7] < threshold) cubeindex |= 128;

	// If the voxel is entirely outside or inside the surface
	if(tables->edgeTable[cubeindex] == 0) return 0;

	// Find the vertices where the cube intersects the surface
	if(tables->edgetable[cubeindex] & 1)
		vertlist[0] = VertexInterpolate(grid.p[0])
}

/*
 * Outputs  an stl file in binary. First 80 bytes are the header, next 4 contain the number of faces.
 * Facets are then recorded using 50 bytes for each, where normal and vertex coords is stored in three 32 bit floats, closed by a uint of 0.
 *
 */
void outputBinary(FILE *stlfile, struct Face *headref) {
	struct Face *temp;
	unsigned short np = 0;
	unsigned int count = 0,i;
	fseek(stlfile, 84, SEEK_SET);
	temp = headref;
	while (temp != NULL) {
		count++;
		fwrite(temp->normal, 3, sizeof(float), stlfile);
		for (i = 0; i<3;i++) {
			fwrite(temp->faceVertex[i].coords,sizeof(float),3,stlfile);
		}
		fwrite(&np,2,1,stlfile);
		temp = temp -> next;
	}
	fseek(stlfile, 80, SEEK_SET);
	fwrite(&count, sizeof(count), 1,stlfile);
}

#endif /* IMPROCESS_H_ */
